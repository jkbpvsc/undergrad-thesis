

\section{System Architecture}
\label{label:protocol-design}
In this section we will define the architecture of our authentication system, to so we need to combine the model of password authentication we've examined in \S\ref{section:password-authentication} and the ZKP system for quadratic residuosity problem from \S\ref{zkp-qrp}.

\subsection{Password Verification}
\label{section:zkp-password-verification}
The purpose of password verification is to assert that the user authenticating knows the correct password $p$. 
How can we do this with the ZKP protocol?
The ZKP protocol proves that $x$ is a quadratic residue modulo $n$, by proving the knowledge of the root $w$, where  $w^2 \equiv x \Mod{n}$.
To use this protocol as a password verification method, we can treat the root $w$ as the password $w = p$ known by the user.
If the user assumes the role of prover and the authentication system the role of the verifier, when both follow the ZKP protocol, the user will prove that $x$ is a quadratic residue modulo $n$, to do this however the user needs to prove the knowledge of the password $w$. 
With this, the system can assert that the password is valid.

\subsubsection{Vulnerability}
To verify the proof provided by the user, the system needs to know the quadratic residue $x$.
Because the root $w = p$ is a password, this introduces a vulnerability as mentioned in \S\ref{label:password-vulnerabilities}.
An attacker with access to $x$ could crack the password $w$ in an offline attack with pre-computed tables.
As mentioned in \S\ref{paragraph:password-hashing}, we need to use a key-stretching method to ensure adequate security against offline attacks.

\subsubsection{Theoretical Constraints of Key-Stretching Vulnerable Data}
A common usage of a key-stretching method is to transform the vulnerable data stored in the authentication system.
However, this approach doesn't work in our case.
Let us explore how the authentication system verifies the proof, and why using key-stretching directly over stored data is an issue.
We assume the system can verify the proof and use key-stretching methods directly over the vulnerable data. 
However, we will see why this is not possible.

\newpage
\paragraph{Proof Verification with Key-Stretched Data}
\label{paragraph:problems-with-key-stretch}
On the last step of the protocol the system verifies that
$$ z^2 \equiv yx^b \Mod{n}.$$
%If we were to protect the vulnerable value $x$, by stretching it with a function $H$
If we stretch the vulnerable value $x$ with a function $H$ and a salt $s$
$$H(x, s) = x_H,$$
we can then verify the proof with an inverse function $H^{-1}$
$$z^2 = yH^{-1}(x_H, s)^b.$$
This is possible assuming a polynomial algorithm $H^{-1}$ exists, however, since key-stretching methods are based on hashing functions which are one-way functions, we know that the probability of a polynomial algorithm $H^{-1}$ to successfully compute a \textit{pseudo-inverse} is negligibly small, for all positive integers $c$ \cite{goldreich2007foundations}
$$\Pr[H(H^{-1}(H(x))) = H(x)] < |x|^{-c}.$$
Even if given unbounded time and resources, the \textit{pseudo-inverse} $x' = H^{-1}(H(x))$ might not be equal to $x' \not = x$. 
The set $x'\in I_x$ are all values that map into $H(x) = H(x')$, and since $H$ is not injective we know that $|I_x| \ge 1$.
Meaning that the probability that $x' = x$ is
\medskip
$$\Pr[H^{-1}(H(x)) = x] = \frac{1}{|I_x|}.$$

\subsubsection{Key-Stretching the Root $w$}
We've seen that key-stretching the vulnerable value $x$ prevents us from verifying the ZKP.
However, by increasing the entropy of the root $w$, we can eliminate the vulnerability and ensure adequate security.

\bigskip
\noindent Instead of treating the password $p$ as the root $w$, we can instead derive the root $w$ from the password $p$, by stretching it with a function $H$ and a salt $s$
$$w = H(p, s),$$
and use the output as the root $w$.
This way we've ensured the same level of protection as if we stretched the data stored in the system.
Because we didn't change the value $x$, we can verify the proof without being affected by issues mentioned in \S\ref{paragraph:problems-with-key-stretch}.

\newpage
\subsection{Secure Authentication Process using ZKPs}
By key-stretching the password to derive the root $w$, we've figured out how to secure our system while respecting the constraints imposed by the proof verification process.
How does this change the authentication process we've described in \S\ref{section:zkp-password-verification}?

\bigskip
\noindent
The process begins with the user computing the root $w$ from the password $w$ and salt $s$.

\begin{table}[h!]
	\centering
	\begin{tabular}{p{0.016\textwidth}|p{0.25\textwidth}|p{0.03\textwidth}|p{0.3\textwidth}}
  		& User & & Authentication System\\
  		\hline
		1 & $w = H(P, s)$ & & \\ 
	\end{tabular}
\end{table}

\noindent
Once the user computes the root $w$, he can authenticate by following ZKP protocol with the system, as mentioned in \S\ref{zkp-qrp}
Earlier we argued the ZKP works as a password verification method because $p = w$, this argument isn't true anymore.
However, even though $w \not = p$, the user can only derive $w$ knowing the password $p$, so when the user proves the knowledge of $w$, it can only be so because they know $p$ as well.

\begin{table}[h!]
	\centering
	\begin{tabular}{p{0.016\textwidth}|p{0.25\textwidth}|p{0.03\textwidth}|p{0.3\textwidth}}
  		&  & & \\
		\hline
		1 & $u \leftarrow_R \Bbb{Z}_{n}$ &  \\
		& $y = u^2$ & $\xrightarrow{y}$ \\
		2 & & $\xleftarrow{b}$ & $b \leftarrow_R \{0, 1\} $ \\
		3 & $z = uw^b \Mod n $ & $\xrightarrow{z}$ & assert $z^2 \equiv yx^b \Mod{n}$\\ 
	\end{tabular}
\end{table}

\noindent
We repeat this part of the process $m$ times for a confidence of $1 - 2^{-m}$.
 
\subsection{Considerations}
\label{section:pefromance-considerations}
\paragraph{Performance.}
If we look at the steps that occur in our ZKP verification process, we can notice many iterations of data exchanges between the user and the system.
In a real world environment, this can cause the authentication process to be slow because of network inefficiencies when transmitting data between the user and the authentication system.
Can we improve this by running the steps in parallel instead of sequentially?
If we inspect the data, we can see that at any step there are no dependencies to data from the previous step, meaning that technically nothing is preventing us from running this in parallel.

What we are proposing is theoretically called a 3-round interactive zero-knowledge proof.
The existence of these proofs is limited only to a class of problems \textit{BPP} \cite{goldreich1996composition}.
Unfortunately, the quadratic residuosity problem is not believed to be in this class, so we assume a parallel proof to have a weaker notion of zero-knowledge.

For this purpose, we've used a sequential execution for our authentication process.