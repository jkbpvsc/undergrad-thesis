\section{Authentication Protocol as an EAP Method}
To define an EAP method for the PBA-ZKP-QRP protocol, we need to define the protocol execution between a peer and the verifier, by defining message subtypes, their data format, and rules for handling them.
We also explore different approaches of mapping between PBA-ZKP-QRP message pairs and EAP messages, and their performance.

\subsection{EAP Packet Format}
An EAP packet is $n$ octets long.

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|}
	\hline
	1 & 1 & 2 & 1 & 1 & $n - 6$\\
	\hline
	Code & Identifier & Length & Type & Subtype & Subtype Data\\
	\hline 
\end{tabular}
\end{center}

\paragraph{Code}
The code field is one octet

\bigskip

\begin{tabular}{ll}
	1 & Request \\
	2 & Response\\
\end{tabular}

\paragraph{Identifier} The identifier field is one octet, and is being used to match request and response packets.

\paragraph{Length} Two octets Subtypelong, used to indicate the length of the EAP packet.

\paragraph{Type} One octet long.

\bigskip

\begin{tabular}{ll}
	84 & EAP PB-ZKP-QRP \\
\end{tabular}

\paragraph{Subtype} One octet long

\bigskip 

\begin{tabular}{ll}
	1 & SETUP \\ %TODO: Better names
	2 & ZKP-QRP \\
\end{tabular}
\bigskip
\newline
The subtype format describes only the contents of the \textit{subtype data} field.

\subsubsection{Subtype 1 Request}

EAP Subtype 1 request must be sent after obtaining the peers identity. The identity can be acquired with the EAP-Identity (Type 1) packet, or determined somehow otherwise.

The peers identity is used to look up the password salt $s$ and semiprime modulus $n$.

\bigskip

\begin{center}
\begin{tabular}{|c|c|c|}
	\hline
	1 & $4 \le n \le 255 $ & $64 \le m$\\ %TODO: Maybe change n to some other letter to avoid confusion with semiprime n
	\hline
	Salt Length & Salt & Semiprime Modulus\\
	\hline
\end{tabular}
\end{center}

\paragraph{Salt Length}
A single octet for the length of the \textit salt field in octets. %TODO: Maybe reword copied from EAP-SRP-RFC

\paragraph{Salt}
A random salt value, should be from 4 octets to 255 octets long.
The max length is determined by the max number able to be encoded in the \textit {salt length} field.

\paragraph{Semiprime Modulus}
Fills the rest of the message to the length specified by the \textit length field in the EAP header. %TODO: Maybe reword copied from EAP-SRP-RFC
Should be at least 64 octets (512 bits).


\subsubsection{Subtype 1 Response}
The request of this subtype serves to complete the setup phase of the protocol, at the same time the response already includes the $y$ value required at the start of each cycle of the second part of the protocol.

\begin{center}
\begin{tabular}{|c|}
	\hline
	$n$ \\
	\hline
	Square $y$\\
	\hline
\end{tabular}
\end{center}

\bigskip

\paragraph{Square $y$} Computed by the peer, as $y = u^2$, where $u \leftarrow_R \Bbb{Z}_{n}^{*}$. Fills the remainder of the message in $n$ octets.

\subsubsection{Subtype 2 Request}

\begin{center}
\begin{tabular}{|c|}
	\hline
	$1$ \\
	\hline
	Random Bit $b$\\
	\hline
\end{tabular}
\end{center}

\paragraph{Random Bit $b$} A single-bit, at the right-most place. The bit value is randomly chosen by the authenticator. 1 octet long.

\subsubsection{Subtype 2 Response}

\begin{center}
\begin{tabular}{|c|c|c|}
	\hline
	$1$ & $n \le 255 $ & $m$\\
	\hline
	Witness Length & Witness $z$ & Square $y$\\ %TODO: Witness, check if this is the correct term?
	\hline
\end{tabular}
\end{center}

\paragraph{Witness Length} A field one octet in length. Determines the length of the Witness field in octets.

\paragraph{Witness} Fields length is limited by the max value of the \textit{witness length} field at 255 octets.
The witness $z$ is computed by the peer, as $z = uw^b$, where $u$ was generated for the subtype 1 response, bit $b$ was provided in the request, and $w$ is the provers private input.

\paragraph{Square $y$} Field fills up the remainder of the message. 
Square $y$ is the same value as in the subtype 1 response.
It is generated and sent in the $n$-th cycle, to help verify the witness in the $(n+1)$-th cycle.
Same rules apply as when generating the $y$ value if the response to subtype 1 request.

\paragraph{Verification}
When authenticator receives the \textit{subtype 2 response}, it checks the witness, by verifying $z^2 \equiv yx^b \Mod{n}$.
If verification fails the authenticator should send a \textit{failure} message to the peer, and he authentication should be terminated.
After successfully verifying the witness, the authenticator can decided to continue the protocol by sending a \textit{subtype 2 request} or decide to authenticate the user, by sending a \textit success message.
The authenticator can decide an authentication is successful when the protocol reaches a desired confidence of $1 - \frac{1}{2^m}$, by iterating for $m$ times.

\subsection{Optimisations}
EAP is a lock-step protocol, the authenticator and the peer exchange request and response messages.

A naive mapping of PBA-ZKP-QRP messages to EAP packets yields 3 new request/response pairs. 
We can reduce the amount of new pairs to 2 instead of 3, by interlacing data shared in each pair.
This way we obtain a faster performance by reducing the number of packet needed to be exchanged.

\subsubsection{Naive Map}

\begin{center}
	\begin{tabular}{c|rcl}
	Pair & Peer  & $\leftrightarrow$ & Authenticator \\
	\hline
	1 & & $\xleftarrow{s, n}$ &\\
	&& $\xrightarrow{\textvisiblespace}$&\\
	\hline
	2 & & $\xleftarrow{\textvisiblespace}$&\\
	&& $\xrightarrow{y}$&\\
	\hline
	3 & & $\xleftarrow{b}$&\\
	&& $\xrightarrow{z}$&\\
	\hline
	\end{tabular}
\end{center}

\paragraph{Pair 1} Exchanged once after the authenticator obtaining the peers identity. The authenticator sends the salt $s$ and semiprime modulus $n$ to the peer, in order for the peer to compute the private input $w$. 
Peers response serves as an acknowledgement of a successful setup.

This pair corresponds to the \textit{setup} part of the protocol.

\paragraph{Pair 2} The authenticator requests the peer to generate the \textit{square} value $y$ and share it in the response.

This pair corresponds to the ZKP-QRP part of the protocol and is repeated for $m$ times. %TODO: Update the terminology to use ZKP-QRP everwhere

\paragraph{Pair 3} The authenticator requests the peer to compute the \textit{witness} value $z$, with the value of the random bit $b$ in the request data.

This pair corresponds to the ZKP-QRP part of the protocol and is repeated for $m$ times.

\paragraph{Performance}
With this mapping a successful protocol run of $m$ iterations with a probability of error of $2^{-m}$, would require a minimum of $4m + 3$ packet exchanges.

\bigskip

\begin{center}
	\begin{tabular}{r|l}
		Packets exchanged & Type\\
		\hline
		2 & Pair 1\\
		$2m$ & Pair 2\\
		$2m$ & Pair 3\\
		1 & Type 2 (Success)\\
	\end{tabular}
\end{center}

\subsubsection{Interlaced Data Mapping}

\begin{center}
	\begin{tabular}{c|rcl}
	Pair & Peer  & $\leftrightarrow$ & Authenticator \\
	\hline
	1 & & $\xleftarrow{\text{s, n}}$ &\\
	&& $\xrightarrow{y_1}$&\\
	\hline
	2 & & $\xleftarrow{b}$&\\
	&& $\xrightarrow{z, y_{n+1}}$&\\
	\hline
	\end{tabular}
\end{center}

\paragraph{Pair 1} Exchanged once after the authenticator obtains the peers identity. 
The authenticator sends the salt $s$ and semiprime modulus $n$ to the peer, in order for the peer to compute the private input $w$.
Peer computes the square value $y$ and sends it in the response.

The main difference with the naive mapping is that the peer responds prematurely with $y$, instead of in the response to naive pair 2. %TODO: Reword, weird sentence
This is possible and valid, because the semiprime modulus value $n$ required to compute $y$, is provided in the pair 1 request.

\paragraph{Pair 2}
The authenticator already has the square value $y$, and sends a request with a random bit $b$. 
The peer computes sends the \textit{witness} $z$ and the square value $y_{n+1}$, used in the next iteration of the protocol

This is possible because the computation of square value $y$ is only dependent on the modulus $n$, which is provided in the request pair 1.

\paragraph{Performance}
With this mapping a successful protocol run of $m$ rounds with an error rate $2^{-m}$, would require a minimum of $2m + 3$ packet exchanges.

\begin{center}
\begin{tabular}{r|l}
	Packets exchanged & Type\\
	\hline
	2 & Pair 1\\
	$2m$ & Pair 2\\
	1 & Type 2 (Success)\\
\end{tabular}
\end{center}

Comparing the performance of both mappings, the interlaced mapping requires half as many exchanges for the same $m$ rounds of protocol.

$$\lim_{1 \rightarrow \infty} \frac{2m + 3}{4m + 3} = \frac{1}{2}$$

\bigskip
\subsection{Security}
EAP PB-ZKP-QRP is resistant to passive attacks to over-the-wire information, eavesdropping, active attacks and offline attacks with pre-computed tables/rainbow tables.

The protocol does not enable mutual authentication, nor helps in deriving a session key that can be used for data encryption.
