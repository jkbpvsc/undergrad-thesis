\section{Password-based Authentication using Zero-Knowledge Proof of Quadratic Residues}

The original paper on zero-knowledge proofs outlined a zero-knowledge proof protocol based on the problem of quadratic residues.

\subsection{Protocol} %TODO: Restructure to focus soley on ZKPQR as PBA

Public inputs $n,x: (\frac{x}{n}) = 1$ and\\
Provers private input $w: x \equiv w^2 \Mod{n}$\\
\begin{center}
\begin{tabular}{rl}
	P $\rightarrow$ V: & Choose $u \leftarrow_R \Bbb{Z}_{n}^{*}$; Send $y = u^2$\\
	V $\rightarrow$ P: & Choose $b \leftarrow_R \{0, 1\} $; Send $b$\\
	P $\rightarrow$ V [$b = 0$]: & Send $u$\\
	P $\rightarrow$ V [$b = 1$]: & Send $z = w \cdot u \Mod{n}$\\
	V [$b = 0$]: & Check $z^2 \equiv y \Mod{n}$\\
	V [$b = 1$]: & Check $z^2 \equiv xy \Mod{n}$\\
\end{tabular}
\end{center}

This protocol is repeated $m$ times, for a confidence of $1 - 2^{-m}$.

% Security
\subsection{Security}

%TODO Maybe use passive/active attack terminology
\subsubsection{Offline Attacks}
The input $x$ is used by the Verifier to verify the proof, it is computed from the private input $w$ as $x = w^2 \Mod n$.
The $w$ is the Provers private input and represents the users password in a password-based authentication system.

The problem in an application of this protocols in the storage of $w$.
In modern password-based authentication system, the password is processed by a resource expensive password key derivation function, and the authentication is verified by comparing the derived values.
Our protocol prevents us from using key derivation in this way, because without the original or "plaintext" value $x$ we cannot verify the proofs provided by the Prover.

However storing the "plaintext" values of $x$, enables an attacker to easily pre-compute a table of possible $x$ values.

% Key derivation function
%TODO Pick a different title
\subsubsection{?? Client-Side Key Derivation}
Our wish is to use a hashing function with salt on the password and use the original value of $x$ for verification.
To achieve both requirements, the password is hashed before used to calculate the $x$ used for verification in the authentication process.
This approach is similar to the one used in \cite{wu1998secure} the Secure Remote Password protocol.
Using a hashing function $H$, a random salt $s$ and users password $P$, we can derive $w$ and $x$.

$$w = H(P, s)$$
$$x = w^2 \Mod n$$

\subsection{Protocol}
Using the NIST Digital Identity Guidelines \cite{grassi2017}.

\paragraph{Values}
\begin{center}
	\begin{tabular}{rl}
		$q, p$ & Primes, where $q \ne p$\\
		$n$ & Modulo number, where $n = qp$\\ %TODO check the correct term for this 
		$P$ & Provers password \\
		$I$ & Provers identifier \\
		$H$ & Hashing function \\
		$s$	& Salt\\
		$w$ & Password hash, where $w = H(P, s)$\\ %TODO check the correct term for this
		$x$ & Integer, where $x = w^2 \Mod{n}$ %TODO check the correct term for this
	\end{tabular}
\end{center}


\paragraph{Enrolment} In the enrolment process the CSP provides the $n$ modulo value to the Applicant.
The Applicant generates a random salt $s$ and computes a private $w$ value from the password $P$, $w = H(P, s)$.
Applicant next computes $x = w^2 \Mod{n}$ and submits the identifier $I$ and $x$ to the CSP.

\bigskip

\begin{center}
\begin{tabular}{rl}
	CSP $\rightarrow$ Ap: & Send $n$\\
	Ap: & Generate $s$\\
	Ap: & Compute $w = H(P, s)$\\
	Ap: & Compute $x = x^2 \Mod{n}$\\
	Ap $\rightarrow$ CSP: & Send $I, x, s$
\end{tabular}
\end{center}

\bigskip

%TODO Make sure this checks out.
CSP binds $x$ and $s$ as the authenticator to the credential $I$.

\paragraph{Authentication}

Authentication happens in two part, in the first part minimal data is exchanged between the Claimant and the Authenticator. The Claimant identifies himself and the Authenticator provides the $n$ and the salt $s$. %TODO Give $n$ a name
In the second part the protocol for ZKP of Quadratic Residuosity is executed between the Claimant and the Authenticator. %TODO Check spelling

To draw parallels between the terminology used in the ZKP of Quadratic Residuosity \cite{GMR} and the NIST Digital Identity Guidelines \cite{grassi2017}. The Prover is the Claimant, and the Verifier is the Authenticator.

\bigskip

\paragraph{First Part (Setup)}

The Claimant sends an identifier $I$ to the Authenticator, which responds with modulo $n$ and the salt $s$. The Claimant uses both values to compute the private input $w$ of the ZKPQR protocol.

\bigskip

\begin{center}
	\begin{tabular}{rl}
	C $\rightarrow$ Au: & Send $I$\\
	Au $\rightarrow$ C: & Send $n, s$\\
	C: & Computes $w = H(P, s)$\\
\end{tabular}
\end{center}

\paragraph{Second Part (ZKPQR)}
This part is same as the ZKPQR protocol described in the \cite{GMR}.

\bigskip

\begin{center}
\begin{tabular}{rl}
	C $\rightarrow$ Au: & Choose $u \leftarrow_R \Bbb{Z}_{n}^{*}$; Send $y = u^2$\\
	Au $\rightarrow$ C: & Choose $b \leftarrow_R \{0, 1\} $; Send $b$\\
	P $\rightarrow$ V [$b = 0$]: & Send $u$\\
	P $\rightarrow$ V [$b = 1$]: & Send $z = w \cdot u \Mod{n}$\\
	V [$b = 0$]: & Check $z^2 \equiv y \Mod{n}$\\
	V [$b = 1$]: & Check $z^2 \equiv xy \Mod{n}$\\
\end{tabular}
\end{center}

% Enrolment

% Authentication